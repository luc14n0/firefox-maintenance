# HG changeset patch
# User msirringhaus@suse.de
# Date 1582805876 -3600
#      Thu Feb 27 13:17:56 2020 +0100
# Node ID cc3d09abea31068e57f1ab918782f9f86fc6a158
# Parent  7c2bddde658687c3fa2a6f2a89b6e2beae44f3e5
imported patch decoder_workaround.patch

diff --git a/image/decoders/nsGIFDecoder2.cpp b/image/decoders/nsGIFDecoder2.cpp
--- a/image/decoders/nsGIFDecoder2.cpp
+++ b/image/decoders/nsGIFDecoder2.cpp
@@ -416,16 +416,19 @@ void nsGIFDecoder2::ConvertColormap(uint
       qcms_transform_data(transform, aColormap, aColormap, aColors);
     }
   }
 
   // Expand color table from RGB to BGRA.
   MOZ_ASSERT(mSwizzleFn);
   uint8_t* data = reinterpret_cast<uint8_t*>(aColormap);
   mSwizzleFn(data, data, aColors);
+#if MOZ_BIG_ENDIAN()
+  SwizzleRow(SurfaceFormat::A8R8G8B8, SurfaceFormat::B8G8R8A8)(data, data, aColors);
+#endif
 }
 
 LexerResult nsGIFDecoder2::DoDecode(SourceBufferIterator& aIterator,
                                     IResumable* aOnResume) {
   MOZ_ASSERT(!HasError(), "Shouldn't call DoDecode after error!");
 
   return mLexer.Lex(
       aIterator, aOnResume,
diff --git a/image/decoders/nsJPEGDecoder.cpp b/image/decoders/nsJPEGDecoder.cpp
--- a/image/decoders/nsJPEGDecoder.cpp
+++ b/image/decoders/nsJPEGDecoder.cpp
@@ -252,30 +252,34 @@ LexerTransition<nsJPEGDecoder::State> ns
 
       // We're doing a full decode.
       switch (mInfo.jpeg_color_space) {
         case JCS_GRAYSCALE:
         case JCS_RGB:
         case JCS_YCbCr:
           // By default, we will output directly to BGRA. If we need to apply
           // special color transforms, this may change.
+#if MOZ_BIG_ENDIAN()
+          mInfo.out_color_space = MOZ_JCS_EXT_NATIVE_ENDIAN_XRGB;
+#else
           switch (SurfaceFormat::OS_RGBX) {
             case SurfaceFormat::B8G8R8X8:
               mInfo.out_color_space = JCS_EXT_BGRX;
               break;
             case SurfaceFormat::X8R8G8B8:
               mInfo.out_color_space = JCS_EXT_XRGB;
               break;
             case SurfaceFormat::R8G8B8X8:
               mInfo.out_color_space = JCS_EXT_RGBX;
               break;
             default:
               mState = JPEG_ERROR;
               return Transition::TerminateFailure();
           }
+#endif
           break;
         case JCS_CMYK:
         case JCS_YCCK:
           // libjpeg can convert from YCCK to CMYK, but not to XRGB.
           mInfo.out_color_space = JCS_CMYK;
           break;
         default:
           mState = JPEG_ERROR;
diff --git a/image/decoders/nsPNGDecoder.cpp b/image/decoders/nsPNGDecoder.cpp
--- a/image/decoders/nsPNGDecoder.cpp
+++ b/image/decoders/nsPNGDecoder.cpp
@@ -351,26 +351,34 @@ nsresult nsPNGDecoder::InitInternal() {
 
   return NS_OK;
 }
 
 LexerResult nsPNGDecoder::DoDecode(SourceBufferIterator& aIterator,
                                    IResumable* aOnResume) {
   MOZ_ASSERT(!HasError(), "Shouldn't call DoDecode after error!");
 
-  return mLexer.Lex(aIterator, aOnResume,
+  LexerResult res = mLexer.Lex(aIterator, aOnResume,
                     [=](State aState, const char* aData, size_t aLength) {
                       switch (aState) {
                         case State::PNG_DATA:
                           return ReadPNGData(aData, aLength);
                         case State::FINISHED_PNG_DATA:
                           return FinishedPNGData();
                       }
                       MOZ_CRASH("Unknown State");
                     });
+
+#if MOZ_BIG_ENDIAN()
+  if(res.is<TerminalState>() && res.as<TerminalState>() == TerminalState::SUCCESS) {
+      NativeEndian::swapToLittleEndianInPlace<uint32_t>((uint32_t*)(mImageData), mImageDataLength / 4);
+  }
+#endif
+
+  return res;
 }
 
 LexerTransition<nsPNGDecoder::State> nsPNGDecoder::ReadPNGData(
     const char* aData, size_t aLength) {
   // If we were waiting until after returning from a yield to call
   // CreateFrame(), call it now.
   if (mNextFrameInfo) {
     if (NS_FAILED(CreateFrame(*mNextFrameInfo))) {
diff --git a/image/decoders/nsWebPDecoder.cpp b/image/decoders/nsWebPDecoder.cpp
--- a/image/decoders/nsWebPDecoder.cpp
+++ b/image/decoders/nsWebPDecoder.cpp
@@ -242,17 +242,22 @@ nsresult nsWebPDecoder::CreateFrame(cons
             ("[this=%p] nsWebPDecoder::CreateFrame -- create decoder error\n",
              this));
     return NS_ERROR_FAILURE;
   }
 
   // WebP doesn't guarantee that the alpha generated matches the hint in the
   // header, so we always need to claim the input is BGRA. If the output is
   // BGRX, swizzling will mask off the alpha channel.
+#if MOZ_BIG_ENDIAN()
+  mBuffer.colorspace = MODE_ARGB;
+  SurfaceFormat inFormat = mFormat;
+#else
   SurfaceFormat inFormat = SurfaceFormat::OS_RGBA;
+#endif
 
   SurfacePipeFlags pipeFlags = SurfacePipeFlags();
   if (mFormat == SurfaceFormat::OS_RGBA &&
       !(GetSurfaceFlags() & SurfaceFlags::NO_PREMULTIPLY_ALPHA)) {
     pipeFlags |= SurfacePipeFlags::PREMULTIPLY_ALPHA;
   }
 
   Maybe<AnimationParams> animParams;
